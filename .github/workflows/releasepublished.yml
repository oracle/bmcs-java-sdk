# This workflow triggers when a new release has been made.

name: ReleasePublished

# Controls when the action will run. 
on:
  # Triggers the workflow on push or pull request events but only for the main branch
  release:
    types: [released]

  # Allows you to run this workflow manually from the Actions tab.
  workflow_dispatch:
    inputs:
      release:
        description: 'Release version number ("latest" or "v3.3.0.0")'
        required: true
        default: latest
      repo_name:
        description: 'Repository name (leave blank for this repo)'
        required: false
      file_name_part:
        description: 'File name part (substring of file name to use)'
        required: true
        default: individual-modules.zip

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # TODO: If this runs in an environment, set this value
    # environment: MC-Action

    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      - name: Report the parameters
        run: |
          echo "GITHUB_REF is \"$GITHUB_REF\""
          echo "GITHUB_SHA is \"$GITHUB_SHA\""
          echo "inputs.release is \"${{github.event.inputs.release}}\""
          if [ -z "${{github.event.inputs.release}}" ]; then
            echo "Release not set manually, using GITHUB_REF"
            export RELEASE=`echo "$GITHUB_REF" | sed "s#refs/tags/##"`
          else
            echo "Release set manually, using inputs.release"
            export RELEASE=${{github.event.inputs.release}}
          fi
          echo "Release is $RELEASE"
          pat="^v.*"
          if [ "$RELEASE" = "latest" ]; then
            echo "Using latest release"
          elif [[ $RELEASE =~ $pat ]]; then
            echo "Specified '$RELEASE' as release"
          else
            echo "Unsupported release, should be 'latest' or something like 'v3.3.0.0'; was '$RELEASE'"
            exit 1
          fi
          if [ -z "${{github.event.inputs.repo_name}}" ]; then
            echo "Repo name not set manually, using '${GITHUB_REPOSITORY}'"
            export REPO=${GITHUB_REPOSITORY}
          else
            echo "Repo name specified as '${{github.event.inputs.repo_name}}'"
            export REPO=${{github.event.inputs.repo_name}}
          fi
          if [ -z "${{github.event.inputs.file_name_part}}" ]; then
            echo "File name part not set manually, using 'individual-modules.zip'"
            export FILE_NAME_PART="individual-modules.zip"
          else
            echo "File name part specified as '${{github.event.inputs.file_name_part}}'"
            export FILE_NAME_PART="${{github.event.inputs.file_name_part}}"
          fi
          echo "RELEASE=$RELEASE" >> $GITHUB_ENV
          echo "REPO=$REPO" >> $GITHUB_ENV
          echo "FILE_NAME_PART=$FILE_NAME_PART" >> $GITHUB_ENV
      - name: Configure GPG Key
        env:
          MCKEY: ${{ secrets.MCKEY }}
        run: |
          set -x
          mkdir -p ~/.gnupg/
          chown -R $(whoami) ~/.gnupg/
          chmod 700 ~/.gnupg
          gpg --version
          echo "MCKEY is '$MCKEY'"
          if [ -z ${MCKEY+x} ]; then echo "MCKEY is unset"; else echo "MCKEY is set to '$MCKEY'"; fi
          printf "$MCKEY" | base64 --decode > ~/.gnupg/mckey_private.key
          ls ~/.gnupg
          gpg --import ~/.gnupg/mckey_private.key
          gpg --list-keys
      - name: Download the release asset
        env:
          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
        run: |
          if [ "$RELEASE" = "latest" ]; then
            echo "Using latest release"
            set +e
            curl -f -H "Authorization: Bearer $ACCESS_TOKEN" -H 'Accept: application/vnd.github.v3.raw' -s https://api.github.com/repos/$REPO/releases > releases.json
            result="$?"
            if [ "$result" -ne 0 ]; then
              echo "curl returned '$result': Bad access token or repo (was '$REPO')"
              exit $result
            fi
            asset_id=`cat releases.json | jq ".[0].assets | map(select(.name|test(\"$FILE_NAME_PART\")))[0].id"`
            result="$?"
            if [ "$result" -ne 0 ]; then
              echo "jq returned '$result': No releases or bad file (was '$FILE_NAME_PART')"
              cat releases.json
              exit $result
            fi
            if [ "$asset_id" == "null" ]; then
              echo "jq returned asset id '$asset_id': No releases or bad file (was '$FILE_NAME_PART')"
              cat releases.json
              exit 1
            fi
            set -e
          else
            echo "Using release $RELEASE"
            set +e
            curl -f -H "Authorization: Bearer $ACCESS_TOKEN" -H 'Accept: application/vnd.github.v3.raw' -s https://api.github.com/repos/$REPO/releases > releases.json
            result="$?"
            if [ "$result" -ne 0 ]; then
              echo "curl returned '$result': Bad access token or repo (was '$REPO')"
              exit $result
            fi
            asset_id=`cat releases.json | jq ". | map(select(.tag_name == \"$RELEASE\"))[0].assets | map(select(.name|test(\"$FILE_NAME_PART\")))[0].id"`
            result="$?"
            if [ "$result" -ne 0 ]; then
              echo "jq returned '$result': Bad release (was '$RELEASE') or bad file (was '$FILE_NAME_PART')"
              cat releases.json
              exit $result
            fi
            if [ "$asset_id" == "null" ]; then
              echo "jq returned asset id '$asset_id': Bad release (was '$RELEASE') or bad file (was '$FILE_NAME_PART')"
              cat releases.json
              exit 1
            fi
            set -e
          fi
          echo "Asset id for release $RELEASE file $FILE_NAME_PART is $asset_id"
          wget -q --header="Authorization: Bearer $ACCESS_TOKEN" --auth-no-challenge --header='Accept:application/octet-stream' https://api.github.com/repos/$REPO/releases/assets/$asset_id -O asset.zip
      - name: Examine artifact
        run: |
          ls
          mkdir unpacked
          cd unpacked
          unzip -q ../asset.zip
          find .
      - name: GPG sign all Maven files
        run: |
          set -x
          cd unpacked/maven
          find . -type f -not -name \*.asc | xargs -n 1 -I % gpg --output %.asc --detach-sig %
          find .
